export const eblocks = [{"deep":0,"guide":0,"hasNext":false,"openid":"d6fdeabd0a4ffcbc12cadbcc1e8659db","parent":"ba28320f31cad34cb3f690bde371bb85","value":"## redding\r\n\r\n最缘由：remeber + 自定义\r\n\r\n衍生想法：re(重复) + 自定义，\r\n\r\n翻译后发现redd现在分词redding（整顿,弄整洁）\r\n\r\n我还是喜欢记住自定义，所以我想要这个服务的核心功能就是在web页面自定义的控制一些内容。\r\n\r\n所以弄成本地笔记？\r\n\r\n## 奇思妙想开始\r\n\r\n\r\n","category":1,"created":1599105358937,"hash":"83a84be35a5f4613c9465d409ee55fe1e8769c64","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105362930},{"deep":0,"guide":0,"hasNext":false,"openid":"a067d48f5a9bcf03927bde9fbf60a20f","parent":"a5168983af25e9d9136c62eb801b82e7","value":"## redding目的  \r\n\r\n借鉴\r\n\r\n- [notion](https://www.notion.so/)\r\n- [wolai](www.wolai.com)\r\n- [evernote](evernote.com/)\r\n- [onenote](https://www.onenote.com/)\r\n- [processon](processon.com)\r\n- [xmind](xmind.cn)\r\n- [keep](keep.google.com)\r\n- [whiteboard](http://oxoyo.co/XBoard/)\r\n- [whiteboard-ziteboard](app.ziteboard.com)\r\n- [whiteboard-windows](localhost)\r\n\r\n等一系列的笔记，想来实现一个存于*浏览器*的笔记。\r\n\r\n目的：一切皆为自定义话的进行保存自己的笔记的内容。\r\n\r\n数据格式： 以节点为单位，树形为结构。\r\n\r\nvue + typescript + vuex\r\n\r\n利用一些其他的开源代码，监听键盘，管理样式  \r\n，管理函数，动态管理模块，开放化自己的数据  \r\n管理层次，开放化网页的利用性。\r\n\r\n想以*new Function()*的形式进行在浏览器端运  \r\n行代码，以至于，可以人为的自定义自己的这个网站。\r\n\r\n以前端来操作的东西，都一单页应用浏览器来进行  \r\n操作，网页存在多姿多彩的，而思考以自定义化的  \r\n方式进行保存那些网页的内容到自己的网页中，然  \r\n后导出，导入。\r\n\r\n我想以vscode的编辑代码类型的方式来作为一个网  \r\n页的笔记模块，亦或者数据模块。命令行，插件，  \r\n快捷键，文件目录。而网页本身又可以做到图片，  \r\n画图，3d，动画，游戏，可反馈操作，动态编辑元  \r\n素，源码共享等等。\r\n\r\n从上到下，我觉得很好的软件，优点\r\n\r\n### 印象笔记\r\n\r\n我觉得标签很不错，搜索功能，剪藏功能\r\n\r\n### notion\r\n\r\n块结构的笔记，数据表形式的笔记\r\n\r\n### onenote\r\n\r\n画画画\r\n\r\n### progress\r\n\r\n流程图\r\n\r\n### whiteboard\r\n\r\n画图\r\n","category":1,"created":1599105379479,"hash":"56997046cb788e7de30177d90cd649fada045c81","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105403585},{"deep":0,"guide":0,"hasNext":false,"openid":"d9a555831dee3fe2b5cb75285d3d64e4","parent":"a5168983af25e9d9136c62eb801b82e7","value":"code123","category":1,"created":1599105382286,"hash":"416c3e87affd150953517f8387f942a905e9c0d6","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105410938},{"deep":0,"guide":0,"hasNext":false,"openid":"e046a273ce84c74340fce848ec763893","parent":"61cb30aff1fd1b2964c859be9041d840","value":"## 结构思考\r\n\r\n我一直在思考和想要去找到的一个解决问题，就是自定话自己提交和得到的数据，\r\n\r\n然后我又可以自定义话的去通过相应的数据自己去完善某一些东西，只要数据格式  \r\n到位，那么，我就可以一定的在应用程序当中实现我自己需要的功能部分，所以  \r\n我思考了很久，不，我通过很长时间过度，在心血来潮的时候去摸索得到的方案是  \r\n什么。然后我得到了一个不是结果的结果。web。\r\n\r\n我过去每一次访问网站，都会去想要一个功能，我知道这个网站的数据，我想要控制  \r\n那些我想要的数据显示，我不想的数据，就给我隐藏，所有的网站都是如此，怎么去  \r\n做呢？我唯一想到的是做一个插件，这个插件具有一些脚本命令，当我访问这一些网页  \r\n的时候，存在一些结构去隐藏和显示元素。油猴是一个很好的，但是油猴不能登录，\r\n第二，油猴仅仅只能作为插件。我之前想，我想要知道所有的网站，我就想，我能不能  \r\n通过去得到所有的ip去得到所有的网站，通过爬虫去抓取和分析网站类型，然后根据  \r\n网站分类，理所当然的我失败了，因为ip是大量的，而网站也是大量的，同样的大多数  \r\n网站是无意的。这些网站和油猴然后思考互相的关系，然后我去想，这些东西都怎么样  \r\n去和用户绑定起来。我想，每一个用户访问一个网站，都具有对应的信息，用户的信息  \r\n自定义保存到他自己需要的服务器当中，在需要的时候自定义的再拿出来，那么是不是  \r\n在浏览器就可以得到自己想要的那一部分内容了。怎么绑定关系？\r\n\r\n我在云途的时候想，我有一个服务器，服务器的不同端口对应我开发的不同的项目，我  \r\n又记不得这些端口，那么有没有一个好的方式去让服务记得，然后可以编辑，然后可以  \r\n获得，不同对应的名字获取对应的内容呢？我想的是json保存，但是json修改容易，得  \r\n到容易，但是不好看呀？所以我就想以json保存，yml显示。又，如果我改yml，如何去  \r\n对应修改json，我在yml调整顺序？我又如何对应的在json修改，（突然想起来了，json  \r\n编辑器好像是一个公司的题目，而我想通过json对应保存我的端口，然后去实现的一个轻\r\n功能，然后结合起来了），当时我考虑的是把json深层递归下去，把递归的数据，根据数据  \r\n的类型分别赋予数据类型，字符串，数组，数字，对象，然后把对象和数组一直递归到底层  \r\n直到字符串和数字或为空，然后每一个节点都有一个父节点。\r\n\r\n所以我推想了一个结构，如下图：\r\n\r\n![json转数组](https://download.xiongxiao.me/manual/json%E8%BD%AC%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B.jpg)\r\n\r\n把json转为树结构，那么把每一个数节点对应起来，那么就可转为数据了。然后通过数据  \r\n转json，也很方便，两者对应修改内容也很方便。\r\n\r\n```js\r\nmodel {\r\n    id  // 当前索引\r\n    parent // 父节点\r\n    deep    // 深度\r\n    hasNext  //是否拥有下一个\r\n    type    // 类型\r\n    key     // 键名\r\n    value   // 键值\r\n}\r\n```\r\n\r\n当时的代码\r\n```js\r\ninterface ContentInterface {\r\n    openid?: string, // openid 生成\r\n    id: number, // id定位\r\n    key: string | number, // key的值\r\n    value: string, // 值， 如果type类型为Object或者Array 则为空\r\n    parent: number, // 父节点的id\r\n    deep: number, // 深度\r\n    hasNext?: boolean, // 是否还有子节点\r\n    type: string,\r\n}\r\n\r\nexport class JsonContent {\r\n    public content: ContentInterface[];\r\n    public originString: string = '';\r\n    public originJson: object = {};\r\n    public error: Boolean = false;\r\n    public errorContent: string = '';\r\n\r\n    private hasValueType = [\"string\", \"number\"]\r\n    constructor(contentJson: string | Object){\r\n        // contentJson \r\n        // 1. 如果是 `object` 直接转换\r\n        // 2. 如果是 `str`  判断是否是字符串\r\n        const fultureJson: Object = this.strOrObjectToObject(contentJson);\r\n        this.content = []\r\n        this.jsonToContent(fultureJson);\r\n    }\r\n    /**\r\n     * 转Str或者Object 得到内容\r\n     */\r\n    public fromStr(contentJson: string | Object){\r\n        this.content = []\r\n        const fultureJson: Object = this.strOrObjectToObject(contentJson);\r\n        this.jsonToContent(fultureJson);\r\n        return this\r\n    }\r\n    public toStr(content: ContentInterface[] = []) {\r\n        if(content.length === 0){\r\n            content = this.content;\r\n        }\r\n        return JSON.stringify(this.contentToJson(content));\r\n    }\r\n    public toStr2(content: ContentInterface[] = [], hasBlank=2) {\r\n        if(content.length === 0){\r\n            content = this.content;\r\n        }\r\n        return JSON.stringify(this.contentToJson(content), null, hasBlank);\r\n    }\r\n    public deleteNode(pos: number){\r\n        const MaxLength = this.content.length;\r\n        const getJson = this.content;\r\n\r\n        for(let i=0;i < MaxLength;i++){\r\n            if(getJson[i].id === pos){\r\n                pos = i;\r\n                break\r\n            }\r\n        }\r\n        const childNumber:number[] = [];\r\n        childNumber.push(getJson[pos].id);\r\n\r\n        if(pos >= MaxLength) {\r\n            this.content.pop();\r\n            return this.content\r\n        }\r\n        let offset = pos;\r\n        for(let i = pos+1; i< getJson.length; i++){\r\n            if(childNumber.includes(getJson[i].parent)){\r\n                childNumber.push(getJson[i].id);\r\n            } else{\r\n                break;\r\n            }\r\n            offset = i;\r\n        }\r\n        getJson.splice(pos,offset-pos+1)\r\n        return this\r\n    }\r\n    // 转默认的Object\r\n    private strOrObjectToObject(contentJson: string | Object){\r\n        this.originString = JSON.stringify(contentJson)\r\n        this.originJson = JSON.parse(this.originString)\r\n\r\n        let fultureJson: Object = {}\r\n        if (typeof contentJson === \"string\"){\r\n            try{\r\n                fultureJson = JSON.parse(contentJson);\r\n                this.error = false;\r\n                this.errorContent = \"\";\r\n            }catch(e){\r\n                console.log(\"错误\", e);\r\n                console.error(e.toString())\r\n                this.error = true;\r\n                this.errorContent = e.toString();\r\n            }\r\n        } else {\r\n            fultureJson = contentJson;\r\n        }\r\n        return fultureJson;\r\n    }\r\n    /**\r\n     * 功能函数\r\n     * @param contentJson \r\n     */\r\n    private jsonToContent(contentJson: any, parent_id: number = -1, deep_id: number =0){    \r\n\r\n        for(let i of Object.keys(contentJson)){\r\n            // console.log(\"key\",i,typeof i, )\r\n            // console.log(\"value\", contentJson[i], typeof contentJson[i])\r\n            const id:number = this.length();\r\n            const key:string = i;\r\n            const parent:number = parent_id;\r\n            const deep:number = deep_id;\r\n            \r\n            let value: string = \"\";\r\n            let type: string =\"string\";\r\n\r\n            const getType = typeof contentJson[i];\r\n\r\n           \r\n            if(this.hasValueType.includes(getType)){\r\n                value = contentJson[i];\r\n            }else{\r\n                value = \"\";\r\n            }\r\n            type = this.getContentType(contentJson[i])\r\n\r\n            // 处理content的类型\r\n            const input_content: ContentInterface = {\r\n                id,\r\n                key,\r\n                value,\r\n                parent,\r\n                deep,\r\n                type\r\n            }\r\n            this.content.push(input_content);\r\n\r\n            if(type === \"object\" || type === \"array\") {\r\n                this.jsonToContent(contentJson[i], id, deep_id + 1)\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 功能函数 Array To Object\r\n     * @param getJson \r\n     */\r\n    private contentToJson(getJson:ContentInterface[]){\r\n        let resultObject:any = {};\r\n        for(let i =0; i< getJson.length; i++) {\r\n            if(this.hasValueType.includes(getJson[i].type)){\r\n                resultObject[getJson[i].key] = getJson[i].value;\r\n            }\r\n            const parentGetJsonType = getJson[i].type \r\n            if(getJson[i].value === \"array-3\"){\r\n                console.log(\"array\", getJson[i])\r\n            }\r\n            if(parentGetJsonType === \"object\" || parentGetJsonType === \"array\"){\r\n                const children:ContentInterface[] = [];\r\n                const childNumber:number[] = [];\r\n                const parentKey = getJson[i].key\r\n                childNumber.push(getJson[i].id);\r\n                if(i >= getJson.length) {\r\n                    resultObject[getJson[i].key] = {};\r\n                    continue;\r\n                }\r\n                for(i++;i< getJson.length; i++){\r\n                    if(childNumber.includes(getJson[i].parent)){\r\n                        childNumber.push(getJson[i].id);\r\n                        children.push(getJson[i]);   \r\n                    } else{\r\n                        break;\r\n                    }\r\n                }\r\n                if(parentGetJsonType === \"object\"){\r\n                    resultObject[parentKey] = this.contentToJson(children);\r\n                }else{\r\n                    let resultArray = []\r\n                    const resultFromContentToJson = this.contentToJson(children);\r\n                    for(let jKey of Object.keys(resultFromContentToJson)){\r\n                        resultArray.push(resultFromContentToJson[jKey])\r\n                    }\r\n                    resultObject[parentKey] = resultArray;\r\n                }\r\n                i--;\r\n            }\r\n        }\r\n        return resultObject;\r\n    }\r\n\r\n    private getContentType(contentJson: any): string {\r\n        // typeof能判断的基本类型：undefined，string，boolean，number，object，Function\r\n        // return typeof contentJson;\r\n        if(typeof contentJson !== \"object\"){\r\n            return  typeof contentJson;\r\n        }else{\r\n            if (Array.isArray(contentJson)){\r\n                return \"array\";\r\n            }else {\r\n                return \"object\";\r\n            }\r\n        }\r\n    }\r\n    private length(){\r\n        return this.content.length;\r\n    }\r\n}\r\n\r\nexport default {\r\n    \"title\": \"function\"\r\n}\r\n```\r\n\r\n从这一个结构回源，想到了ip寻址，路由关系，局域网关系，我json转数组的结构只是一层的局域的  \r\n内容，一个树外还有另一个树。所以往外推，就是一个网状结构。\r\n\r\n然，数据是什么，结构是这样，但是其中的数据是什么，其中的数据，图片，文字，音频，视频，交互?  \r\n\r\n只要有一个树的枝干在，我想，如果对于一个喜欢自定义的，我可以在树的枝干上挂任何一个果实，不必  \r\n拘泥于形状，说到这里，我就很喜欢json数据，可拓展性极强，另一句话说，我获取数据的类很容易，一切  \r\n的数据现在存放的格式从整备的格式（关系型数据库）,到现在的非关系型数据库，发展下来，感觉数据已经  \r\n不在拘泥于格式，形状，方法，任意的，只要你懂这个数据是什么，那么可以用自己懂的方式去实现数据的  \r\n理解，所以我想，把数据的存放留给用户自己，显示的方法留给自己，value的格式是不定向的。\r\n\r\n核心：树，图。树的节点数据任意，树的关系，父父子子。\r\n\r\n### 所以想到结构-就是二叉树\r\n","category":1,"created":1599105471347,"hash":"5849dbfade76f342d83a6923b3e6f3598c04d339","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105491050},{"deep":0,"guide":0,"hasNext":false,"openid":"0c626468c2e1d673a5db4bd5cfb5093b","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 是作为一个笔记而计划的\r\n> redding使用技术\r\n\r\n作为一个笔记，记录一个人书写的任何的内容，可以把内容放到本地，根据自己想要的方式存放。\r\n\r\n然后可拓展？思考如何去拓展？\r\n\r\n## 使用\r\n\r\n基础使用vue+typescript+cloudbase进行开发\r\n\r\n```js\r\n\"@cloudbase/js-sdk\": \"^1.2.2\",\r\n\"ace-builds\": \"^1.4.12\",\r\n\"axios\": \"^0.20.0\",\r\n\"cos-js-sdk-v5\": \"^0.5.27\",\r\n\"crypto-js\": \"^4.0.0\",\r\n\"dexie\": \"^3.0.2\",\r\n\"element-ui\": \"^2.13.2\",\r\n\"hotkeys-js\": \"^3.8.1\",\r\n\"marked\": \"^1.1.1\",\r\n\"moment\": \"^2.27.0\",\r\n\"register-service-worker\": \"^1.7.1\",\r\n\"throttle-debounce\": \"^2.3.0\",\r\n\"turndown\": \"^6.0.0\",\r\n\"uuid\": \"^8.3.0\",\r\n\"vue\": \"^3.0.0-rc.9\",\r\n\"vue-class-component\": \"^8.0.0-0\",\r\n\"vue-router\": \"^4.0.0-0\",\r\n\"vuex\": \"^4.0.0-0\"\r\n```\r\n\r\n从我使用的顺序，记忆的顺序\r\n\r\n## typescript\r\n\r\n## console.log使用工具\r\n\r\n## markdwon编辑（互转）\r\n\r\n## crypto 哈希值\r\n\r\n## moment日期格式\r\n\r\n## ace-builds编辑器\r\n\r\n## throttle-debounce\r\n\r\n## hotkeys-js\r\n\r\n## vuex\r\n\r\n## dexie\r\n\r\n## axios\r\n\r\n## 腾讯云云开发和cos包\r\n\r\n## web文件导入导出\r\n\r\n## window对象","category":1,"created":1599105508672,"hash":"276c90aa0138fdac7695c8f345cf76b6a6af84e5","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105529122},{"deep":0,"guide":0,"hasNext":false,"openid":"8fd4ad95ae0a5e52d9962af62325016b","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 02 console\r\n\r\n第一个参数可以是一个包含格式化占位符输出的字符串，例如：\r\n\r\n```js\r\nconsole.log(\"The %s jumped over %d tall buildings\", animal, count);\r\n```\r\n\r\n上面的例子可以用下面的无格式化占位符输出的代码替换：\r\n\r\n```js\r\nconsole.log( \" The \" , animal,  \" jumped over \" , count,  \" tall buildings \" );\r\n```\r\n\r\n并且，这两种方式是可以组合使用的。如果使用了格式化占位符，而提供的参数的个数多于占位符的个数，那么，多余的参数会以空格分隔的方式附加在字符串后面，就像：\r\n\r\n```js\r\nconsole.log( \" I am %s and I have: \" , myName, thing1, thing2, thing3);\r\n```\r\n\r\n如果参数是一个Javascript对象，那么在控制台输出的就不是静态文字，而是一个可交互的超链接，点击超链接可以查看该对象的HTML, CSS, Script, DOM窗口，可用格式化字符串%o代替Javascript对象。\r\n\r\n```js\r\nconsole.log( \" Body tag is %o \" , document.body);\r\n%s\t    字符串\r\n%d, %i\t整型（暂不支持数字型）\r\n%f\t    浮点型 （暂不支持数字型）\r\n%o,%O\t链接对象\r\n%c\t    应用提供的CSS font-size: 30px;\r\n```\r\n\r\n```js\r\nconsole.debug(object[, object, ...])\r\n```\r\n\r\n在控制台输出一条消息，包含一个指向代码调用位置的超链接。假如是直接在控制台输入该命令，就不会出现超链接（和console.log()一样）。\r\n\r\n```js\r\nconsole.info(object[, object, ...])\r\n```\r\n\r\n在控制台输出一条带有“信息”图标的消息和一个指向代码调用位置的超链接。\r\n\r\n```js\r\nconsole.warn(object[, object, ...])\r\n```\r\n\r\n在控制台输出一条带有“警告”图标的消息和一个指向代码调用位置的超链接。\r\n\r\n```js\r\nconsole.error(object[, object, ...])\r\n```\r\n\r\n在控制台输出一条带有“错误”图标的消息和一个指向代码调用位置的超链接。\r\n\r\n```js\r\nconsole.assert(expression[, object, ...])\r\n```\r\n\r\n测试表达式expression是否为真。如果不是真，会在控制台写一条消息并抛出异常\r\n\r\n```js\r\nconsole.dir(object)\r\n```\r\n\r\n以列表形式输出一个对象的所有属性，有点和你查看DOM窗口相类似。\r\n\r\n```js\r\nconsole.dirxml(node)\r\n```\r\n\r\n输出一个HTML或者XML元素的XML源代码。和你在HTML窗口看到的相似。\r\n\r\n```js\r\nconsole.trace() //打印追踪\r\n```\r\n\r\n```js\r\nconsole.group(object[, object, ...])\r\n```\r\n\r\n输出一条消息，并打开一个嵌套块，块中的内容都会缩进。调用console.groupEnd()关闭块。该命令可以嵌套使用。\r\n\r\n```js\r\nconsole.groupEnd()\r\n```\r\n\r\n关闭最近一个由console.group打开的块。\r\n\r\n```js\r\nconsole.time(name)\r\n```\r\n\r\n创建一个名字为name的计时器，调用console.timeEnd(name)停止计时器并输出所耗时间（毫秒）。\r\n\r\n```js\r\nconsole.timeEnd(name)\r\n```\r\n\r\n停止同名的计时器并输出所耗时间（毫秒）。\r\n\r\n```js\r\nconsole.profile([title])\r\n```\r\n\r\n打开Javascript性能测试开关。可选参数title会在打印性能测试报告时在报告的开头输出。\r\n\r\n```js\r\nconsole.profileEnd()\r\n```\r\n\r\n关闭Javascript性能测试开关并输出报告。\r\n\r\n```js\r\nconsole.count([title])\r\n```\r\n\r\n触发一个计数，计数由1开始。可选参数title会在显示计数时在报告的开头输出。","category":1,"created":1599105597768,"hash":"9408812f907e8ee8cd741a81a82a6d10b5c3491e","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105625466},{"deep":0,"guide":0,"hasNext":false,"openid":"d7c2e132962e04e741b3ebcb3e211478","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 03 markdown \r\n\r\nmarkdown转html（marked)  \r\nhtml转markdown(turndown)  \r\n\r\nmarked可扩展高亮\r\n`marked(markdownString [,options] [,callback])`\r\n\r\nturndown 根据分词设定是否转换，我这里设置table转换的时候table标签保留。因为table标签，转回来的时候消失，不会自动转换为markdown格式，就会互转的过程样式丢失。\r\n\r\n为了更好的优化，我设定了css为xion和v的元素保留，可以根据style进行自己设定style的显示格式。\r\n\r\n```js\r\nimport marked from \"marked\";\r\nimport TurndownService, { Options } from 'turndown';\r\nimport { getStyle } from \"./style\";\r\n\r\nconst parseText = ( text: string ) => {\r\n    return marked(text);\r\n}\r\nconst parseHtml = ( html: string) => {\r\n    const turndownService: any = new TurndownService();\r\n    turndownService.keep(['table'])\r\n    turndownService.addRule('strikethrough', {\r\n        filter: ['xion'],\r\n        replacement: function (content: any, node: HTMLElement) {\r\n          const style = getStyle(node);\r\n          const setStyle = style === \"\" ? \"\" : ` style=\"${style}\"`\r\n          return `<xion${setStyle}>` + content\r\n        }\r\n      })\r\n    turndownService.addRule('strikethrough', {\r\n        filter: (node: HTMLElement, options: Options) => {\r\n            const nodeName = node.nodeName.toLowerCase();\r\n            if(nodeName.startsWith(\"v\")){\r\n                return true\r\n            }\r\n        },\r\n        replacement: function (content: any, node: HTMLElement, options: Options) {\r\n            const nodeName = node.nodeName.toLowerCase();\r\n            const style = getStyle(node);\r\n            let setStyle = style === \"\" ? \"\" : ` style=\"${style}\"`\r\n            if(nodeName === \"v\") setStyle=\"\"\r\n            return `<${nodeName}${setStyle}>` + content\r\n          }\r\n    })\r\n    const markdown = turndownService.turndown(html)\r\n    return markdown;\r\n}\r\nexport  {\r\n    parseText,\r\n    parseHtml\r\n}\r\n```","category":1,"created":1599105630076,"hash":"a8c1951469d384575ee6d38f98916b0a77f86b7b","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105650040},{"deep":0,"guide":0,"hasNext":false,"openid":"368130c6cab6e556a0f92ff54e68cadb","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 04 hash and uuid\r\n\r\nuuid版本具有四种\r\n\r\nUUID Version 1：基于时间的UUID\r\n基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。由于在算法中使用了MAC地址，这个版本的UUID可以保证在全球范围的唯一性。但与此同时，使用MAC地址会带来安全性问题，这就是这个版本UUID受到批评的地方。如果应用只是在局域网中使用，也可以使用退化的算法，以IP地址来代替MAC地址－－Java的UUID往往是这样实现的（当然也考虑了获取MAC的难度）。\r\n\r\nUUID Version 2：DCE安全的UUID\r\nDCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。\r\n\r\nUUID Version 3：基于名字的UUID（MD5）\r\n基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。\r\n\r\nUUID Version 4：随机UUID\r\n根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的。\r\n\r\nUUID Version 5：基于名字的UUID（SHA1）和版本3的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。\r\n\r\nuuid是为了获取唯一值，我想如果基于时间，两个相同的用户同一分秒创建，那么uuid是否就重复了，所以v1和v4两个一起用了。\r\n\r\n```js\r\nimport { v1 as uuidv1 } from \"uuid\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\n\r\nconst getUUID = (num: number) => {\r\n  switch (num) {\r\n    case 1:\r\n      return uuidv1().replace(/-/g, \"\");\r\n    case 4:\r\n      return uuidv4().replace(/-/g, \"\");\r\n    default:\r\n      break;\r\n  }\r\n  return uuidv1().replace(/-/g, \"\");\r\n};\r\n\r\nexport { uuidv1, uuidv4, getUUID };\r\n\r\n```\r\n\r\n获取hash的值，验证两个笔记是否相同\r\n\r\n```js\r\nimport CryptoJS from \"crypto-js\";\r\nimport { getUUID } from \"./uuid\";\r\nconst getHash = (content: string) => {\r\n  return CryptoJS.SHA1(content).toString();\r\n};\r\nconst getOpenid = () => {\r\n  return CryptoJS.MD5(getUUID(1) + getUUID(4)).toString();\r\n};\r\nexport enum CryptoDoing {\r\n  Encrypt,\r\n  Decrypt\r\n}\r\nexport const getRES = (msg:string, flag=CryptoDoing.Encrypt, secret:string=\"a1b1c1-reding\") => {\r\n  if(flag === CryptoDoing.Encrypt){\r\n    return CryptoJS.AES.encrypt(msg, secret).toString();\r\n  }else if(flag === CryptoDoing.Decrypt){\r\n    return CryptoJS.AES.decrypt(msg, secret).toString(CryptoJS.enc.Utf8);\r\n  }\r\n}\r\n```\r\n","category":1,"created":1599105631551,"hash":"460de96af6467b618f80b550f01f85da7a15df6c","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105667627},{"deep":0,"guide":0,"hasNext":false,"openid":"0a5616f27f6017647c96b515f5289d58","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 05 moment日期格式化\r\n\r\n\r\n```js\r\nimport moment from \"moment\";\r\n\r\n// moment().format();                                // \"2014-09-08T08:02:17-05:00\" (ISO 8601, no fractional seconds)\r\n// moment().format(\"dddd, MMMM Do YYYY, h:mm:ss a\"); // \"Sunday, February 14th 2010, 3:25:50 pm\"\r\n// moment().format(\"ddd, hA\");                       // \"Sun, 3PM\"\r\n// moment().format(\"[Today is] dddd\");               // \"Today is Sunday\"\r\n// moment('gibberish').format('YYYY MM DD');         //\r\n//  moment().format(\"Y/M/D hh:mm:ss\")\r\n// \"2020/9/3 09:53:01\"\r\nconst getMoFormat = (date: Date, fmt ='YY/M/D hh:mm:ss') => {\r\n  return moment(date).format(fmt);\r\n}\r\nconst getTimestamp = () => {\r\n  return new Date().getTime();\r\n};\r\nconst logTime = (v:any = \"hh\") => {\r\n  console.log(v, new Date().toLocaleString())\r\n}\r\n/**\r\n *对Date的扩展，将 Date 转化为指定格式的String\r\n *月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，\r\n *年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字)\r\n *例子：\r\n *(new Date()).Format(\"yyyy-MM-dd hh:mm:ss.S\") ==> 2020-07-02 08:09:04.423\r\n *(new Date()).Format(\"yyyy-M-d h:m:s.S\")      ==> 2020-7-2 8:9:4.18\r\n */\r\nconst getDateFormat = (date: Date , fmt = \"yy/mm/dd HH:MM:SS\") => {\r\n  let ret;\r\n  const opt: any = {\r\n    \"Y+\": date.getFullYear().toString(), // 年\r\n    \"y+\": date.getFullYear().toString(), // 年\r\n    \"m+\": (date.getMonth() + 1).toString(), // 月\r\n    \"d+\": date.getDate().toString(), // 日\r\n    \"H+\": date.getHours().toString(), // 时\r\n    \"M+\": date.getMinutes().toString(), // 分\r\n    \"S+\": date.getSeconds().toString() // 秒\r\n    // 有其他格式化字符需求可以继续添加，必须转化成字符串\r\n  };\r\n  for (const k in opt) {\r\n    ret = new RegExp(\"(\" + k + \")\").exec(fmt);\r\n    if (ret) {\r\n      fmt = fmt.replace(\r\n        ret[1],\r\n        ret[1].length == 1 ? opt[k] : opt[k].padStart(ret[1].length, \"0\")\r\n      );\r\n    }\r\n  }\r\n  return fmt;\r\n};\r\nconst df = getDateFormat;\r\nexport { \r\n  getTimestamp,\r\n  getDateFormat,\r\n  getMoFormat,\r\n  df,\r\n  moment,\r\n  logTime,\r\n};\r\n```\r\n","category":1,"created":1599105677705,"hash":"879fc358da7e66b63a1dfc4d50ebff5f787c9a46","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105681829},{"deep":0,"guide":0,"hasNext":false,"openid":"4f82469bb65990d431f859cf4cd00635","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 06 ace编辑器\r\n\r\n这是在vue中使用，element是具体对应的元素\r\n\r\n其中初始化具有一些配置\r\n\r\nwebpack module 引入模块需要安装ace-builds，同时使用的时候需要配置如下\r\n\r\n```js\r\nace.config.set(\r\n    \"basePath\", \r\n    \"https://cdn.jsdelivr.net/npm/ace-builds@1.4.3/src-noconflict/\"\r\n)\r\n```\r\n\r\n才能使用 设置Mode（setMode)和设置Theme(setTheme)，否则会报错。\r\n\r\n查看[ace文档](https://ace.c9.io/#nav=api&api=editor)，setShowPrintMargin是控制是否显示，打印边界。默认有一条线在右边，不好看。\r\n\r\n```js\r\nconst element = this.$refs.rightElement;\r\nconst editor = ace.edit(\"editor\", {\r\n    // maxLines: 20, // 最大行数，超过会自动出现滚动条\r\n    minLines: 10, // 最小行数，还未到最大行数时，编辑器会自动伸缩大小\r\n    fontSize: 12, // 编辑器内字体大小\r\n    // theme: this.themePath, // 默认设置的主题\r\n    // mode: this.modePath, // 默认设置的语言模式\r\n    tabSize: 4, // 制表符设置为 4 个空格大小\r\n    readOnly: false,\r\n    highlightActiveLine: false,\r\n    value: this.code\r\n});\r\nace.config.set(\r\n    \"basePath\", \r\n    \"https://cdn.jsdelivr.net/npm/ace-builds@1.4.3/src-noconflict/\"\r\n)\r\n// editor.setTheme(\"ace/theme/monokai\"); \r\neditor.getSession().setMode(\"ace/mode/markdown\");\r\neditor.getSession().setUseWrapMode(true); // 自动换行\r\neditor.setShowPrintMargin(false); \r\nthis.editor = editor;\r\neditor.getSession().on(\"change\", this.onChangeAce);\r\nconst value = this.markdown.value||\"code\";\r\neditor.setValue(value);\r\neditor.clearSelection()\r\neditor.on(\"blur\", this.onFinish);   \r\neditor.focus()\r\n```\r\n\r\n其中html中编辑，有input的textarea，和div设置contenteditable，contenteditable的优点是，样式确定后，只需要修改其中内容即可，绑定了样式。\r\n\r\n理想化方案：我在ace编辑器，放置了一些漂亮的字体，文本，颜色，边框。但是我不想删除的时候去掉，我只需要在右边显示的地方，改其中的内容即可。\r\n","category":1,"created":1599105691149,"hash":"37bbf9f9c3a74dfb026bbbcb0e5c9bd82c9673ce","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105694378},{"deep":0,"guide":0,"hasNext":false,"openid":"89a80c6f2ad185c78ee403e28b5f11a5","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 07 防抖和节流\r\n\r\nthrottle-debounce\r\n\r\n因为内容修改绑定的时候，打字很快的话，可以缓改内容到数据库。\r\n\r\n基本用法是\r\n\r\n创建防抖函数，然后回调\r\n\r\n```js\r\nimport { throttle, debounce } from \"throttle-debounce\";\r\nconst throttleFunc = throttle(1000, false, (call) => {\r\n  call();\r\n});\r\n\r\nconst debounceFunc = debounce(1000, false, call => {\r\n    call();\r\n});\r\n\r\nexport { throttleFunc, debounceFunc, debounce, throttle };\r\n\r\n```","category":1,"created":1599105729938,"hash":"e94574266754b1ec4a23e64fd8b8f12d26591d0a","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105752217},{"deep":0,"guide":0,"hasNext":false,"openid":"885623ad029cff7259bbcca2f83c792f","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 08 hotkeys\r\n\r\n浏览器热键管理,方便dom元素和键盘快捷键的绑定，event是浏览器键盘事件，按键的属性，handler是hotkeys库的监听属性。\r\n\r\n可以用`*`进行匹配，可以多个事件绑定，unbind也很方便。\r\n\r\n```js\r\nhotkeys('ctrl+a,alt+a+s', {keyup: true}, function(event, handler) {\r\n    if (event.type === 'keydown') {\r\n    console.log('keydown:', event.type, handler, handler.key);\r\n    }\r\n\r\n    if (event.type === 'keyup') {\r\n    console.log('keyup:', event.type, handler, handler.key);\r\n    }\r\n    });\r\nhotkeys('*', function(event){\r\n    console.log(\"key=:\", hotkeys.getPressedKeyCodes(), event);\r\n})\r\nhotkeys('ctrl+k,ctrl+s', function(event) {\r\n    event.preventDefault()\r\n})\r\nhotkeys.filter= (event)=>true;\r\nhotkeys.unbind('ctrl+k,ctrl+s', function(event) {\r\n    event.preventDefault()\r\n})\r\n```\r\n\r\nhotkeys会过滤input的内容的输入监听，通过hotkeys.filter = (event)=>any进行自我过滤设置。\r\n\r\n键码和按键对应总结\r\n```js\r\nimport { HotkeysEvent } from 'hotkeys-js';\r\nconst isff =\r\n  typeof navigator !== \"undefined\"\r\n    ? navigator.userAgent.toLowerCase().indexOf(\"firefox\") > 0\r\n    : false; // 绑定事件\r\nconst keyMap:any = {\r\n  backspace: 8,\r\n  tab: 9,\r\n  clear: 12,\r\n  enter: 13,\r\n  return: 13,\r\n  esc: 27,\r\n  escape: 27,\r\n  space: 32,\r\n  left: 37,\r\n  up: 38,\r\n  right: 39,\r\n  down: 40,\r\n  del: 46,\r\n  delete: 46,\r\n  ins: 45,\r\n  insert: 45,\r\n  home: 36,\r\n  end: 35,\r\n  pageup: 33,\r\n  pgup: 33,\r\n  pagedown: 34,\r\n  pgdn: 34,\r\n  capslock: 20,\r\n  pause: 19,\r\n  \"⇪\": 20,\r\n  \",\": 188,\r\n  \".\": 190,\r\n  \"/\": 191,\r\n  \"`\": 192,\r\n  \"-\": isff ? 173 : 189,\r\n  \"=\": isff ? 61 : 187,\r\n  \";\": isff ? 59 : 186,\r\n  \"'\": 222,\r\n  \"[\": 219,\r\n  \"]\": 221,\r\n  \"\\\\\": 220\r\n}; \r\n// Modifier Keys\r\n\r\nconst modifier:any = {\r\n  // shiftKey\r\n  \"⇧\": 16,\r\n  shift: 16,\r\n  // altKey\r\n  \"⌥\": 18,\r\n  alt: 18,\r\n  option: 18,\r\n  // ctrlKey\r\n  \"⌃\": 17,\r\n  ctrl: 17,\r\n  control: 17,\r\n  // metaKey\r\n  \"⌘\": 91,\r\n  cmd: 91,\r\n  command: 91\r\n};\r\n// F1~F12 special key\r\nfor (let k = 1; k < 20; k++) {\r\n    keyMap[\"f\".concat(''+k)] = 111 + k;\r\n}\r\nconst code = function code(x:string) {\r\n  return (\r\n    keyMap[x.toLowerCase()] ||\r\n    modifier[x.toLowerCase()] ||\r\n    x.toUpperCase().charCodeAt(0)\r\n  );\r\n}; // 设置获取当前范围（默认为'所有'）\r\nconst keyboards = [\r\n            ['Esc','F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12'],\r\n            ['`','1','2','3','4','5','6','7','8','9','0','-','=','Delete'],\r\n            ['Tab', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\\\\'],\r\n            ['Caps', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\\'', 'Enter'],\r\n            ['Shift', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 'Shift'],\r\n            ['Ctrl','Command', 'Alt', 'Space', 'Alt', 'Fn', '']\r\n]\r\nconst keyboardsMiddle = [\r\n    ['PrtSc','ScrLk','Pause'],\r\n    ['Ins','Home','PgUp'],\r\n    ['Del','End','PgDn'],\r\n    ['','',''],\r\n    ['','up',''],\r\n    ['left','down','right']\r\n]\r\n\r\nconst keyboardsNumber = [\r\n    ['','','',''],\r\n    ['Num','/','*','-'],\r\n    ['7','8','9','+'],\r\n    ['4','5', '6', '+'],\r\n    ['1','2','3','enter'],\r\n    ['0','del']\r\n]\r\n\r\nconst preventDefault = (event: any) => {\r\n    event.preventDefault();\r\n}\r\n\r\nexport {\r\n  preventDefault\r\n}\r\n```","category":1,"created":1599105754474,"hash":"983458f59dbcda13347d13d59264902fc1cc0692","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105763239},{"deep":0,"guide":0,"hasNext":false,"openid":"96d40094e2aa460464fe326cff664044","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 09 vuex store的用法\r\n\r\n基本结构\r\n\r\n```js \r\nconst store = {\r\n    state: ()=>{},\r\n    getters: {},\r\n    mutations: {},\r\n    actions: {},\r\n    modules: {}\r\n}\r\n```\r\n\r\n在vue页面使用的时候，用mapGetters更方便，而把store和map绑定到windows上，开发web版的接口。\r\n\r\n其中actions的函数参数context,payload;  \r\ncontext包含dispatch，commit，getters,state，rootState,rootGetters  \r\n可以异步\r\n\r\n其中mutations的函数的参数为state和payload，不能异步\r\n\r\ngetters的函数的参数为state，如果要获取参数的话，使用\r\n\r\n```js\r\ngetters:{\r\n    g:(state)=>(params)=>state.content;\r\n}\r\n```\r\n\r\n基本映射关系\r\n```js\r\nimport { mapGetters, mapActions, mapMutations, mapState} from \"vuex\";\r\nconst map = (v:any, done:any) => {\r\n  const funcs = {...done(v)};\r\n  for(const i in funcs) {\r\n    funcs[i] = funcs[i].bind(app);\r\n  }\r\n  return funcs;\r\n}\r\nif (window) {\r\n  window.store = store;\r\n  window.smap = {\r\n    getters: (v:string[]) => map(v, mapGetters),\r\n    actions: (v:string[]) => map(v, mapActions),\r\n    mutions: (v:string[]) => map(v, mapMutations),\r\n    state: (v:string[]) => map(v, mapState),\r\n  }\r\n```\r\n\r\n模块动态注册\r\n\r\n```js\r\nimport { Store } from 'vuex';\r\n\r\nexport const registerModule = (store:Store<any>, module:any) => {\r\n    store.registerModule(module.name,module);\r\n}\r\n```","category":1,"created":1599105776830,"hash":"9be6ccbea5e03cbea134d913bce48b0fb209adb7","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105786176},{"deep":0,"guide":0,"hasNext":false,"openid":"53787c0e8af73f61e5e90fe4bc909601","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 10 dexie\r\n\r\ndexie是使用indexdb的一款开源软件。\r\n\r\n简化了操作indexdb的过程。\r\n\r\n每次更新和获取操作通过事务管理。\r\n[dexie document](https://dexie.org/docs/API-Reference)\r\n\r\n```js\r\nimport Dexie from \"dexie\";\r\nimport { Note } from \"@/models\";\r\nimport { exampleBlocks,examplePages } from '@/models/note/note';\r\nimport {DefaultValue as Default} from \"@/store/default-value\";\r\nimport { setls, getls, clearls, removels } from \"./local-storage\";\r\n\r\nclass NoteDB extends Dexie {\r\n    public notes: Dexie.Table<Note<any>, string>;\r\n    public constructor(){\r\n        super(\"NoteDB\");\r\n        this.version(Default.DB_VERSION.value as number).stores({notes: \"openid,created,updated,hash,keys,title,category,type,parent\"})\r\n        this.notes = this.table(\"notes\")\r\n        console.log(\"version\", Default.DB_VERSION.value)\r\n    }\r\n}\r\n\r\nconst db = new NoteDB();\r\nconst DB_IS_INIT = localStorage.getItem(Default.DB_IS_INIT.name)\r\n// debugger;\r\nif(!DB_IS_INIT){\r\n    db.transaction(\"rw\", db.notes, async()=>{\r\n        const adds = [...exampleBlocks,...examplePages];\r\n        // for(const i in adds){\r\n        //     db.notes.add(adds[i]);\r\n        // }\r\n        db.notes.bulkAdd(adds);\r\n    }).catch(e => {\r\n        alert(e.stack || e);\r\n    })\r\n    setls(Default.DB_IS_INIT)\r\n}\r\n\r\n// db.transaction(\"rw\", db.notes, async()=>{\r\n//     const update = examplePages[0];\r\n//     update.title = \"我是修改的内容1\";\r\n//     db.notes.update(update,update);\r\n// })\r\nexport {\r\n    db\r\n}\r\n```\r\n","category":1,"created":1599105788801,"hash":"802cd9b5e8b058f7d8a6072471da74e510496ad2","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105794972},{"deep":0,"guide":0,"hasNext":false,"openid":"660e61517f7f52be1b995b6d801b0b0d","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 11 axios是一个数据请求的包\r\n\r\n可以在node和浏览器环境通用，而fetch不行。\r\n\r\naxios可以设置截断\r\n\r\n```js\r\n// Add a request interceptor\r\naxios.interceptors.request.use(function (config) {\r\n    // Do something before request is sent\r\n    return config;\r\n  }, function (error) {\r\n    // Do something with request error\r\n    return Promise.reject(error);\r\n  });\r\n\r\n// Add a response interceptor\r\naxios.interceptors.response.use(function (response) {\r\n    // Any status code that lie within the range of 2xx cause this function to trigger\r\n    // Do something with response data\r\n    return response;\r\n  }, function (error) {\r\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\r\n    // Do something with response error\r\n    return Promise.reject(error);\r\n  });\r\n```\r\n\r\n```js\r\nimport axios from \"axios\";\r\nimport {AxiosRequestConfig} from \"axios\";\r\n\r\nconst get = async (url: string, config: AxiosRequestConfig|undefined=undefined) => {\r\n    return await axios.get(url, config);\r\n}\r\nconst post = async (url: string, data: any, config: AxiosRequestConfig|undefined = undefined) => {\r\n    return await axios.post(url, data, config);\r\n}\r\n\r\nexport {\r\n    get, post\r\n}\r\n```\r\n\r\nfetch 的js\r\n\r\n```js\r\nconst params = (data: any) => {\r\n  return Object.keys(data)\r\n    .map((key) => `${key}=${encodeURIComponent(data[key])}`)\r\n    .join(\"&\");\r\n};\r\n\r\nexport const fetchGet = async (url: string, data: any = \"\") => {\r\n  if (data !== \"\") {\r\n    url = url + \"?\" + params(data);\r\n  }\r\n  return await fetch(url)\r\n    .then((res) => res.json())\r\n    .catch((res) => res);\r\n};\r\n\r\nexport const fetchPost = async (\r\n  url: string,\r\n  data: object,\r\n  config: any = undefined\r\n) => {\r\n  return await fetch(url, {\r\n    body: JSON.stringify(data),\r\n    headers: {\r\n      \"content-type\": \"application/json\",\r\n    },\r\n    method: \"POST\",\r\n    mode: \"cors\",\r\n  }).then((res) => res.json());\r\n};\r\n\r\n```","category":1,"created":1599105805365,"hash":"e7c4ae9ad739f9964c0d36f076f90b9b0364b08f","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105810989},{"deep":0,"guide":0,"hasNext":false,"openid":"70c12f09c19dfd6dfae5379ab273f254","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 12 腾讯云云开发和cos包\r\n\r\n[document](https://docs.cloudbase.net/api-reference/webv2/authentication.html)\r\n```js\r\nimport tcb from \"@cloudbase/js-sdk\";\r\n\r\nconst tcbApp = tcb.init({\r\n  env: \"abear2-198d4c\"\r\n});\r\nconst auth = tcbApp.auth({persistence: \"local\"});\r\nconsole.log(\"tcbApp\", tcbApp,auth);\r\n\r\n// 匿名登录\r\nauth.anonymousAuthProvider().signIn().then((res:any)=>console.log(\"匿名登录成功\",res)).catch((err:any)=>console.log(\"err\",err));\r\n//  \r\n// 微信登陆,网页授权,  \r\n// 公众号中服务号才能网页登陆\r\n// 开发者平台创建网站app才能网页登陆\r\nconst provider = auth.weixinAuthProvider({\r\n  appid: \"wx184f11caee374a89\",\r\n  scope: \"snsapi_base\",\r\n});\r\n\r\n```\r\n\r\n自定义登录`signInWithEmailAndPassword(email: string, password: string): Promise<LoginState>`\r\n\r\ncos对象存储\r\n\r\n直接使用开发密钥直接用，推荐使用后端关联配置。使用后端配置，会验证域名请求。\r\n\r\n```js\r\nimport COS from \"cos-js-sdk-v5\";\r\n// const cos = new COS({\r\n//     SecretId: 'AKIDPenyxnfo1zDXf4Kn690jJgrnUDQ7uU',\r\n//     SecretKey: '*',\r\n// });\r\n\r\nconst cos  = new COS({\r\n    // 必选参数\r\n    getAuthorization:  async function (options: any, callback: any) {\r\n        // 服务端 JS 和 PHP 例子：https://github.com/tencentyun/cos-js-sdk-v5/blob/master/server/\r\n        // 服务端其他语言参考 COS STS SDK ：https://github.com/tencentyun/qcloud-cos-sts-sdk\r\n        // STS 详细文档指引看：https://cloud.tencent.com/document/product/436/14048\r\n        await axios('https://redding.xiongxiao.me/sts').then(res=>{\r\n            const data = res.data;\r\n            const credentials = data && data.credentials;\r\n            console.log(\"get authorization\",data);\r\n            if (!data || !credentials) return console.error('credentials invalid');\r\n            callback({\r\n                TmpSecretId: credentials.tmpSecretId,\r\n                TmpSecretKey: credentials.tmpSecretKey,\r\n                XCosSecurityToken: credentials.sessionToken,\r\n                // 建议返回服务器时间作为签名的开始时间，避免用户浏览器本地时间偏差过大导致签名错误\r\n                StartTime: data.startTime, // 时间戳，单位秒，如：1580000000\r\n                ExpiredTime: data.expiredTime, // 时间戳，单位秒，如：1580000900\r\n            });\r\n            console.log(\"sts\", data)\r\n        }).catch(console.log)\r\n    }\r\n});\r\nconsole.log(\"cos\", cos)\r\ncos.putObject({\r\n    Bucket: 'vd-1252152609', /* 必须 */\r\n    Region: 'ap-chengdu',     /* 存储桶所在地域，必须字段 */\r\n    Key: 'exampleobject/test1',              /* 必须 */\r\n    StorageClass: 'STANDARD',\r\n    Body: \"我的文件对象\", // 上传文件对象\r\n    onProgress: function(progressData: any) {\r\n        console.log(JSON.stringify(progressData));\r\n    }\r\n}, function(err: any, data: any) {\r\n    console.log(err || data);\r\n    // params body format error, Only allow File|Blob|String.\r\n});\r\n\r\nexport {\r\n    cos\r\n}\r\n```\r\n\r\n后端配置，使用云函数获取临时密钥\r\n```js \r\n'use strict';\r\nvar STS = require('qcloud-cos-sts');\r\nvar crypto = require('crypto');\r\n\r\nexports.main = async (event, context) => {\r\n    // 配置参数\r\n    var config = {\r\n        secretId: \"**\",\r\n        secretKey: \"**\",\r\n        proxy: process.env.Proxy,\r\n        durationSeconds: 1800,\r\n        bucket: \"vd-1252152609\",\r\n        region: \"ap-chengdu\",\r\n        // 允许操作（上传）的对象前缀，可以根据自己网站的用户登录态判断允许上传的目录，例子： user1/* 或者 * 或者a.jpg\r\n        // 请注意当使用 * 时，可能存在安全风险，详情请参阅：https://cloud.tencent.com/document/product/436/40265\r\n        allowPrefix: '_ALLOW_DIR_/*',\r\n        // 密钥的权限列表\r\n        allowActions: [\r\n            // 所有 action 请看文档 https://cloud.tencent.com/document/product/436/31923\r\n            // 简单上传\r\n            'name/cos:PutObject',\r\n            'name/cos:PostObject',\r\n            // 分片上传\r\n            'name/cos:InitiateMultipartUpload',\r\n            'name/cos:ListMultipartUploads',\r\n            'name/cos:ListParts',\r\n            'name/cos:UploadPart',\r\n            'name/cos:CompleteMultipartUpload'\r\n        ],\r\n    };\r\n\r\n    // 获取临时密钥\r\n    var LongBucketName = config.bucket;\r\n    var ShortBucketName = LongBucketName.substr(0, LongBucketName.lastIndexOf('-'));\r\n    var AppId = LongBucketName.substr(LongBucketName.lastIndexOf('-') + 1);\r\n    var policy = {\r\n        'version': '2.0',\r\n        'statement': [{\r\n            'action': config.allowActions,\r\n            'effect': 'allow',\r\n            'resource': [\r\n                'qcs::cos:' + config.region + ':uid/' + AppId + ':prefix//' + AppId + '/' + ShortBucketName + '/' + config.allowPrefix,\r\n            ],\r\n        }],\r\n    };\r\n    var startTime = Math.round(Date.now() / 1000);\r\n    const getTempkeys = await new Promise((resolve, rejects)=>{\r\n        STS.getCredential({\r\n            secretId: config.secretId,\r\n            secretKey: config.secretKey,\r\n            proxy: config.proxy,\r\n            region: config.region,\r\n            durationSeconds: config.durationSeconds,\r\n            policy: policy,\r\n        }, function (err, tempKeys) {\r\n            if (tempKeys) tempKeys.startTime = startTime;\r\n            console.log(\"key\", tempKeys)\r\n            resolve(err || tempKeys)\r\n        });\r\n    })\r\n    return getTempkeys;\r\n};\r\n```","category":1,"created":1599105820304,"hash":"9a99ac0d21493a958e52cd6f0f2c197393333009","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105823840},{"deep":0,"guide":0,"hasNext":false,"openid":"ea0f50d9733188c8e83f00beff603f6d","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 13 导入导出数据\r\n\r\n创建链接标签，创建对象输出，数据转换为blob。\r\n\r\n导入是浏览器打开文件，浏览器默认快捷键ctrl+o是打开文件。浏览器打开的文件没有处理会默认被浏览器处理。\r\n\r\n```js\r\n// 自动触发点击事件\r\nconst AutomaticClick = (obj:any) => {\r\n    const ev = document.createEvent(\"MouseEvents\");\r\n    ev.initMouseEvent(\"click\", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\r\n    obj.dispatchEvent(ev);\r\n}\r\n \r\n// 导出文件\r\nconst exportJson = (name:any, data:any) => {\r\n    const urlObject = window.URL || window.webkitURL || window;\r\n    const exportBlob = new Blob([data]);\r\n    const createA:any = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\r\n    createA.href = urlObject.createObjectURL(exportBlob);\r\n    createA.download = name;\r\n    AutomaticClick(createA);\r\n}\r\nconst exportJson2 = (name: any, data: any) => {\r\n    const link = document.createElement('a')\r\n    link.download = name??'notes.json'\r\n    link.href = 'data:text/plain,' + JSON.stringify(data)\r\n    link.click()\r\n}\r\nconst importJson = async ( callback: any) => {\r\n    // 创建一个file input\r\n    let input:any = document.createElement('input')\r\n    input.type = 'file'\r\n\r\n    // 绑定onchange事件\r\n    input.onchange = (event: any) => {\r\n        const files = event.target.files\r\n        if (!files || !files.length) {\r\n            input = null\r\n            throw new Error('No files')\r\n        }\r\n        // 当选择文件后，使用FileReader API读取文件，返回数据\r\n        const reader = new FileReader()\r\n        reader.onload = async (event) => {\r\n            try {\r\n                const config = JSON.parse(event.target?.result?.toString()??\"{}\")\r\n                callback(config)\r\n                return config\r\n            } catch (e) {\r\n                throw new Error(e)\r\n            }\r\n            input = null\r\n        }\r\n        reader.readAsText(files[0])\r\n    }\r\n    // 触发上传文件\r\n    setTimeout(() => {\r\n        input.click()\r\n    }, 4000);\r\n    // input.click()\r\n    // AutomaticClick(input)\r\n}\r\nconst callback = (data: any) => {\r\n    console.log(\"callback\", data)\r\n}\r\nexport {\r\n    exportJson,\r\n    exportJson2,\r\n    importJson,\r\n}\r\n// exportJson('1.json', `{\"a\":1}`)\r\n// exportJson2('2.json', `{\"a\":1}`)\r\n\r\n// importJson(callback)\r\n// console.log(\"导入\")\r\n```","category":1,"created":1599105840601,"hash":"ec73c5663b519c9d79ac50521340012216ad151a","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105844341},{"deep":0,"guide":0,"hasNext":false,"openid":"305ee414103796c39e351d5046c0a627","parent":"1c1955d70217e0e9f25fde870a8b1737","value":"## 14 windows对象少记录\r\n\r\n```js\r\n//锚点跳转\r\nfunction goAnchor(selector:any) {\r\n    var anchor = document.querySelector(selector);//获取元素\r\n    if(anchor) {\r\n    \tsetTimeout(()=>{//页面没有渲染完成时是无法滚动的，因此设置延迟\r\n    \t\tanchor.scrollIntoView(); //js的内置方法，可滚动视图位置至元素位置\r\n    \t},500);\r\n    } \r\n};\r\n//获取参数\r\nfunction getQueryString(name: string){\r\n     var reg = new RegExp(\"(^|&)\"+ name +\"=([^&]*)(&|$)\");\r\n     var r = window.location.search.substr(1).match(reg);\r\n     if(r!=null)return  unescape(r[2]); return null;\r\n}\r\n// 使用方法：进入页面，如果带有锚点参数，则跳转至锚点地方，参数值就是id名\r\n// let maodian=this.GetQueryString('anchor');\r\n// if(maodian){\r\n//      goAnchor('#'+maodian);\r\n// }\r\n\r\n// 滚动\r\nfunction scrollTo(left:number=0,top:number=0, behavior:ScrollBehavior=\"smooth\"){\r\n    window.scrollTo( { left, top, behavior });\r\n    // 设置滚动行为为平滑的滚动 smootyh\r\n}\r\n// 滚动偏移\r\nfunction scrollBy(left:number=0,top:number=0, behavior:ScrollBehavior=\"smooth\"){\r\n    window.scrollTo( { left, top, behavior });\r\n    // 设置滚动行为为平滑的滚动 smooth\r\n}\r\n\r\nexport {\r\n\tgoAnchor,\r\n    getQueryString,\r\n    scrollTo,\r\n    scrollBy,\r\n}\r\n```\r\n\r\n全屏\r\n```js\r\nconst exitFullscreen = () => {\r\n  if (document.exitFullscreen) {\r\n    document.exitFullscreen();\r\n  } else if (document.mozCancelFullScreen) {\r\n    document.mozCancelFullScreen();\r\n  } else if (document.webkitExitFullscreen) {\r\n    document.webkitExitFullscreen();\r\n  }\r\n};\r\nconst launchFullScreen = (element:any) => {\r\n  if (element.requestFullscreen) {\r\n    element.requestFullscreen();\r\n  } else if (element.mozRequestFullScreen) {\r\n    element.mozRequestFullScreen();\r\n  } else if (element.webkitRequestFullscreen) {\r\n    element.webkitRequestFullscreen();\r\n  } else if (element.msRequestFullscreen) {\r\n    element.msRequestFullscreen();\r\n  }\r\n}\r\n\r\nexport {\r\n    exitFullscreen,\r\n    launchFullScreen\r\n}\r\n```\r\n\r\n在线监听\r\n\r\n```js\r\nwindow.addEventListener('online',  function(){\r\n    // 网络由异常到正常时触发\r\n   });\r\nwindow.addEventListener('offline', function(){\r\n    // 网络由正常常到异常时触发\r\n});\r\n```\r\n","category":1,"created":1599105854051,"hash":"4bf55b97927b4769fdf349b34facf9a02cf83f70","keys":[],"setting":"","status":13,"tags":[],"title":"","type":205,"updated":1599105857594}]